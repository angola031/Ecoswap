'use client'

import { useState, useEffect, useRef } from 'react'
import { useRouter } from 'next/navigation'
import { motion } from 'framer-motion'
import {
  ChatBubbleLeftRightIcon,
  PaperAirplaneIcon,
  PaperClipIcon,
  FaceSmileIcon,
  MapPinIcon,
  PhoneIcon,
  VideoCameraIcon,
  EllipsisVerticalIcon,
  CheckIcon
} from '@heroicons/react/24/outline'
import { supabase } from '@/lib/supabase'

// ... interfaces existentes ...

interface User {
  id: string
  name: string
  email: string
  avatar: string
  location: string
  user_id?: string // Agregado para consistencia
}

interface ChatModuleProps {
  currentUser: User | null
}

interface ChatMessage {
  id: string
  senderId: string
  content: string
  timestamp: string
  isRead: boolean
  type: 'text' | 'image' | 'location' | 'file'
  metadata?: {
    imageUrl?: string
    fileName?: string
    fileSize?: string
    coordinates?: { lat: number; lng: number }
  }
  reactions?: Record<string, number>
  myReaction?: string
  replyToId?: string
  sender?: {
    id: string
    name: string
    lastName: string
    avatar?: string
  }
}

// ... otras interfaces ...

export default function ChatModule({ currentUser }: ChatModuleProps) {
  const router = useRouter()
  const [conversations, setConversations] = useState<ChatConversation[]>([])
  const [selectedConversation, setSelectedConversation] = useState<ChatConversation | null>(null)
  const [newMessage, setNewMessage] = useState('')
  const [isLoading, setIsLoading] = useState(true)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const textareaRef = useRef<HTMLTextAreaElement>(null)
  const [searchQuery, setSearchQuery] = useState('')
  const [isTyping, setIsTyping] = useState(false)
  const [replyToMessageId, setReplyToMessageId] = useState<string | null>(null)
  const [showProfile, setShowProfile] = useState(false)
  const [openReactionsFor, setOpenReactionsFor] = useState<string | null>(null)
  const imageInputRef = useRef<HTMLInputElement>(null)
  const fileInputRef = useRef<HTMLInputElement>(null)
  const [offeredProduct, setOfferedProduct] = useState<any>(null)
  const [requestedProduct, setRequestedProduct] = useState<any>(null)
  
  // Estado para manejar conexión realtime
  const [realtimeChannel, setRealtimeChannel] = useState<any>(null)

  // Función auxiliar para obtener ID consistente del usuario
  const getCurrentUserId = () => {
    return String(currentUser?.user_id || currentUser?.id || '')
  }

  // Cargar conversaciones reales (sin cambios)
  useEffect(() => {
    const loadConversations = async () => {
      setIsLoading(true)
      try {
        const { data: { session } } = await supabase.auth.getSession()
        console.log('🔐 [ChatModule] Cargando conversaciones - Sesión:', session ? 'Sí' : 'No')
        
        const token = session?.access_token
        if (!token) {
          console.log('❌ [ChatModule] No hay token para cargar conversaciones')
          router.push('/login')
          return
        }
        
        const res = await fetch('/api/chat/conversations', { 
          headers: { Authorization: `Bearer ${token}` } 
        })
        const json = await res.json()
        
        if (!res.ok) throw new Error(json?.error || 'Error cargando chats')
        
        const list: ChatConversation[] = (json.items || []).map((c: any) => ({
          id: String(c.id),
          user: c.user,
          lastMessage: c.lastMessage || '',
          lastMessageTime: c.lastMessageTime ? new Date(c.lastMessageTime).toLocaleTimeString('es-CO', { hour: '2-digit', minute: '2-digit' }) : '',
          unreadCount: c.unreadCount || 0,
          messages: []
        }))
        
        setConversations(list)
        if (list.length > 0 && !selectedConversation) {
          setSelectedConversation(list[0])
        }
      } catch (error) {
        console.error('❌ [ChatModule] Error cargando conversaciones:', error)
        setConversations([])
      } finally {
        setIsLoading(false)
      }
    }
    loadConversations()
  }, [])

  // Cargar mensajes con filtros mejorados
  useEffect(() => {
    const loadMessages = async () => {
      if (!selectedConversation) return
      
      try {
        const chatId = Number(selectedConversation.id)
        if (!chatId) return
        
        const { data: { session } } = await supabase.auth.getSession()
        const token = session?.access_token
        if (!token) {
          router.push('/login')
          return
        }
        
        const res = await fetch(`/api/chat/${chatId}/messages?limit=100`, { 
          headers: { Authorization: `Bearer ${token}` } 
        })
        const json = await res.json()
        
        if (!res.ok) throw new Error(json?.error || 'Error cargando mensajes')
        
        // ✅ FILTROS MEJORADOS: Solo filtrar mensajes del sistema, no mensajes legítimos
        const messages: ChatMessage[] = (json.items || [])
          .filter((m: any) => {
            const content = m.contenido || ''
            // Solo filtrar mensajes automáticos del sistema
            const isSystemMessage = content.includes('__SYSTEM__') || 
                                   content.includes('__AUTO__') ||
                                   (content.includes('Producto Ofrecido') && content.includes('Producto Solicitado'))
            
            return !isSystemMessage && content.trim().length > 0
          })
          .map((m: any) => ({
            id: String(m.mensaje_id),
            senderId: String(m.usuario_id),
            content: m.contenido || '',
            timestamp: new Date(m.fecha_envio).toLocaleString('es-CO', { 
              hour: '2-digit', 
              minute: '2-digit',
              day: '2-digit',
              month: '2-digit'
            }),
            isRead: m.leido,
            type: m.tipo === 'imagen' ? 'image' : m.tipo === 'ubicacion' ? 'location' : 'text',
            metadata: m.archivo_url ? { imageUrl: m.archivo_url } : undefined,
            sender: {
              id: String(m.usuario?.user_id || m.usuario_id),
              name: m.usuario?.nombre || 'Usuario',
              lastName: m.usuario?.apellido || '',
              avatar: m.usuario?.foto_perfil || undefined
            }
          }))
        
        console.log('💬 [ChatModule] Mensajes cargados:', messages.length)
        
        setSelectedConversation(prev => prev ? { ...prev, messages } : prev)
        setConversations(prev => prev.map(c => c.id === String(chatId) ? { ...c, messages } : c))

        // Marcar como leídos
        const readRes = await fetch(`/api/chat/${chatId}/read`, { 
          method: 'POST', 
          headers: { Authorization: `Bearer ${token}` } 
        })
        if (readRes.ok) {
          setConversations(prev => prev.map(c => c.id === String(chatId) ? { ...c, unreadCount: 0 } : c))
        }
      } catch (error) {
        console.error('❌ [ChatModule] Error cargando mensajes:', error)
      }
    }
    loadMessages()
  }, [selectedConversation?.id])

  // ✅ REALTIME MEJORADO: Suscripción más robusta
  useEffect(() => {
    // Limpiar canal anterior
    if (realtimeChannel) {
      supabase.removeChannel(realtimeChannel)
      setRealtimeChannel(null)
    }

    const chatId = Number(selectedConversation?.id)
    if (!chatId) return

    console.log('🔗 [ChatModule] Configurando realtime para chat:', chatId)

    const channel = supabase
      .channel(`chat_${chatId}`, {
        config: {
          broadcast: { self: true }, // ✅ Permitir recibir nuestros propios mensajes
          presence: { key: getCurrentUserId() }
        }
      })
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'mensaje',
        filter: `chat_id=eq.${chatId}`
      }, (payload: any) => {
        console.log('📨 [ChatModule] Nuevo mensaje realtime:', payload)
        
        const m = payload.new
        if (!m) return

        // Evitar duplicados
        const messageId = String(m.mensaje_id)
        const messageExists = selectedConversation?.messages.some(msg => msg.id === messageId)
        if (messageExists) {
          console.log('⚠️ [ChatModule] Mensaje ya existe, ignorando:', messageId)
          return
        }

        const incoming: ChatMessage = {
          id: messageId,
          senderId: String(m.usuario_id),
          content: m.contenido || '',
          timestamp: new Date(m.fecha_envio).toLocaleString('es-CO', { 
            hour: '2-digit', 
            minute: '2-digit',
            day: '2-digit',
            month: '2-digit'
          }),
          isRead: m.leido,
          type: m.tipo === 'imagen' ? 'image' : m.tipo === 'ubicacion' ? 'location' : 'text',
          metadata: m.archivo_url ? { imageUrl: m.archivo_url } : undefined,
          sender: {
            id: String(m.usuario_id),
            name: 'Usuario', // Se puede mejorar obteniendo info del usuario
            lastName: '',
            avatar: undefined
          }
        }

        console.log('✅ [ChatModule] Agregando mensaje realtime:', incoming)

        // Actualizar conversación seleccionada
        setSelectedConversation(prev => {
          if (!prev) return prev
          return {
            ...prev,
            messages: [...prev.messages, incoming],
            lastMessage: incoming.content || incoming.type,
            lastMessageTime: incoming.timestamp
          }
        })

        // Actualizar lista de conversaciones
        setConversations(prev => prev.map(c => c.id === String(chatId) ? {
          ...c,
          lastMessage: incoming.content || incoming.type,
          lastMessageTime: incoming.timestamp,
          // Solo incrementar unread si no es nuestro mensaje
          unreadCount: incoming.senderId !== getCurrentUserId() ? (c.unreadCount || 0) + 1 : c.unreadCount
        } : c))
      })
      .subscribe((status) => {
        console.log('🔌 [ChatModule] Estado realtime:', status)
      })

    setRealtimeChannel(channel)

    return () => {
      console.log('🔌 [ChatModule] Limpiando canal realtime')
      supabase.removeChannel(channel)
      setRealtimeChannel(null)
    }
  }, [selectedConversation?.id, getCurrentUserId()])

  // Scroll automático mejorado
  useEffect(() => {
    const scrollToBottom = () => {
      if (messagesEndRef.current) {
        messagesEndRef.current.scrollIntoView({ 
          behavior: 'smooth', 
          block: 'end' 
        })
      }
    }
    
    // Delay para asegurar que el DOM se haya actualizado
    const timeoutId = setTimeout(scrollToBottom, 100)
    return () => clearTimeout(timeoutId)
  }, [selectedConversation?.messages])

  // ✅ ENVÍO DE MENSAJES MEJORADO
  const handleSendMessage = async () => {
    if (!newMessage.trim() || !selectedConversation) return
    
    const messageContent = newMessage.trim()
    const tempId = `temp-${Date.now()}-${Math.random()}`
    const currentUserId = getCurrentUserId()
    
    // Crear mensaje optimista
    const optimisticMessage: ChatMessage = {
      id: tempId,
      senderId: currentUserId,
      content: messageContent,
      timestamp: new Date().toLocaleString('es-CO', { 
        hour: '2-digit', 
        minute: '2-digit',
        day: '2-digit',
        month: '2-digit'
      }),
      isRead: false,
      type: 'text',
      sender: {
        id: currentUserId,
        name: currentUser?.name || 'Usuario',
        lastName: currentUser?.apellido || '',
        avatar: currentUser?.avatar || undefined
      }
    }

    // Limpiar input inmediatamente
    setNewMessage('')
    setReplyToMessageId(null)

    // Actualización optimista
    const updatedConversation = {
      ...selectedConversation,
      messages: [...selectedConversation.messages, optimisticMessage],
      lastMessage: optimisticMessage.content,
      lastMessageTime: optimisticMessage.timestamp
    }
    
    setSelectedConversation(updatedConversation)
    setConversations(prev => prev.map(conv => 
      conv.id === selectedConversation.id ? updatedConversation : conv
    ))
    
    try {
      const chatId = Number(selectedConversation.id)
      const { data: { session } } = await supabase.auth.getSession()
      const token = session?.access_token
      if (!token) return
      
      console.log('📤 [ChatModule] Enviando mensaje:', messageContent)
      
      const res = await fetch(`/api/chat/${chatId}/messages`, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json', 
          Authorization: `Bearer ${token}` 
        },
        body: JSON.stringify({ 
          contenido: messageContent, 
          tipo: 'texto' 
        })
      })
      
      const json = await res.json()
      if (!res.ok) throw new Error(json?.error || 'Error al enviar')
      
      console.log('✅ [ChatModule] Mensaje enviado exitosamente:', json.message)
      
      // Reemplazar mensaje temporal con el real
      const realMessage: ChatMessage = {
        id: String(json.message.mensaje_id),
        senderId: String(json.message.usuario_id),
        content: json.message.contenido || '',
        timestamp: new Date(json.message.fecha_envio).toLocaleString('es-CO', { 
          hour: '2-digit', 
          minute: '2-digit',
          day: '2-digit',
          month: '2-digit'
        }),
        isRead: json.message.leido,
        type: 'text',
        sender: optimisticMessage.sender
      }
      
      // Actualizar mensaje optimista con datos reales
      setSelectedConversation(prev => prev ? {
        ...prev,
        messages: prev.messages.map(msg => 
          msg.id === tempId ? realMessage : msg
        ),
        lastMessage: realMessage.content,
        lastMessageTime: realMessage.timestamp
      } : prev)
      
      setConversations(prev => prev.map(conv => 
        conv.id === selectedConversation.id ? {
          ...conv,
          lastMessage: realMessage.content,
          lastMessageTime: realMessage.timestamp
        } : conv
      ))
      
    } catch (error) {
      console.error('❌ [ChatModule] Error enviando mensaje:', error)
      
      // Revertir mensaje optimista en caso de error
      setSelectedConversation(prev => prev ? {
        ...prev,
        messages: prev.messages.filter(msg => msg.id !== tempId)
      } : prev)
      
      // Mostrar error al usuario
      if (window.Swal) {
        window.Swal.fire({
          title: 'Error',
          text: 'No se pudo enviar el mensaje. Verifica tu conexión e inténtalo de nuevo.',
          icon: 'error',
          confirmButtonText: 'Entendido',
          confirmButtonColor: '#3B82F6'
        })
      } else {
        alert('Error: No se pudo enviar el mensaje. Verifica tu conexión e inténtalo de nuevo.')
      }
      
      // Restaurar el mensaje en el input
      setNewMessage(messageContent)
    }
  }

  // Función mejorada para verificar si es mensaje propio
  const isOwnMessage = (message: ChatMessage) => {
    const currentUserId = getCurrentUserId()
    return message.senderId === currentUserId
  }

  // ... resto del código sin cambios ...

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSendMessage()
    }
  }

  // ... resto de funciones y JSX sin cambios significativos ...

  // Solo los métodos que necesitan cambios específicos han sido modificados
  // El resto del código permanece igual

  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-20">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-600"></div>
      </div>
    )
  }

  return (
    <div className="h-[calc(100vh-200px)] flex bg-white rounded-lg shadow-sm border border-gray-200">
      {/* El JSX permanece igual, solo se han modificado las funciones de lógica */}
      {/* ... resto del JSX sin cambios ... */}
    </div>
  )
}